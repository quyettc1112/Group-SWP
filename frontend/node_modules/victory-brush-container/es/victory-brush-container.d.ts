import PropTypes from "prop-types";
import React from "react";
import { VictoryContainer, DomainTuple, VictoryContainerProps } from "victory-core";
export interface VictoryBrushContainerProps extends VictoryContainerProps {
    allowDrag?: boolean;
    allowDraw?: boolean;
    allowResize?: boolean;
    brushComponent?: React.ReactElement;
    brushDimension?: "x" | "y";
    brushDomain?: {
        x?: DomainTuple;
        y?: DomainTuple;
    };
    brushStyle?: React.CSSProperties;
    defaultBrushArea?: "all" | "none" | "disable" | "move";
    disable?: boolean;
    handleComponent?: React.ReactElement;
    handleStyle?: React.CSSProperties;
    handleWidth?: number;
    onBrushCleared?: (domain: {
        x: DomainTuple;
        y: DomainTuple;
    }, props: VictoryBrushContainerProps) => void;
    onBrushDomainChange?: (domain: {
        x: DomainTuple;
        y: DomainTuple;
    }, props: VictoryBrushContainerProps) => void;
    onBrushDomainChangeEnd?: (domain: {
        x: DomainTuple;
        y: DomainTuple;
    }, props: VictoryBrushContainerProps) => void;
}
declare type Constructor = new (...args: any[]) => React.Component;
export declare const brushContainerMixin: <TBase extends Constructor>(base: TBase) => {
    new (...args: any[]): {
        getSelectBox(props: any, coordinates: any): React.DetailedReactHTMLElement<{
            key: string;
            width: number;
            height: number;
            x: number;
            y: number;
            cursor: string;
            style: any;
        }, HTMLElement> | null;
        getCursorPointers(props: any): {
            yProps: string;
            xProps: string;
        };
        getHandles(props: any, domain: any): React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | null;
        getRect(props: any): (React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | React.DetailedReactHTMLElement<{
            key: string;
            width: number;
            height: number;
            x: number;
            y: number;
            cursor: string;
            style: any;
        }, HTMLElement> | null)[];
        getChildren(props: any): (string | number | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactFragment | null)[];
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<{}>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        render(): React.ReactNode;
        readonly props: Readonly<{}>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<{}>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<{}>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<{}>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): void;
    };
    displayName: string;
    propTypes: {
        allowDrag: PropTypes.Requireable<boolean>;
        allowDraw: PropTypes.Requireable<boolean>;
        allowResize: PropTypes.Requireable<boolean>;
        brushComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        brushDimension: PropTypes.Requireable<string>;
        brushDomain: PropTypes.Requireable<PropTypes.InferProps<{
            x: PropTypes.Requireable<any[]>;
            y: PropTypes.Requireable<any[]>;
        }>>;
        brushStyle: PropTypes.Requireable<object>;
        defaultBrushArea: PropTypes.Requireable<string>;
        disable: PropTypes.Requireable<boolean>;
        handleComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        handleStyle: PropTypes.Requireable<object>;
        handleWidth: PropTypes.Requireable<number>;
        onBrushCleared: PropTypes.Requireable<(...args: any[]) => any>;
        onBrushDomainChange: PropTypes.Requireable<(...args: any[]) => any>;
        onBrushDomainChangeEnd: PropTypes.Requireable<(...args: any[]) => any>;
        "aria-describedby": PropTypes.Requireable<string>;
        "aria-labelledby": PropTypes.Requireable<string>;
        children: PropTypes.Requireable<string | number | boolean | PropTypes.ReactElementLike | PropTypes.ReactNodeArray>;
        className: PropTypes.Requireable<string>;
        containerId: PropTypes.Requireable<string | number>;
        containerRef: PropTypes.Requireable<(...args: any[]) => any>;
        desc: PropTypes.Requireable<string>;
        events: PropTypes.Requireable<object>;
        height: PropTypes.Requireable<number | undefined>;
        name: PropTypes.Requireable<string>;
        origin: PropTypes.Requireable<PropTypes.InferProps<{
            x: PropTypes.Requireable<number | undefined>;
            y: PropTypes.Requireable<number | undefined>;
        }>>;
        ouiaId: PropTypes.Requireable<string | number>;
        ouiaSafe: PropTypes.Requireable<boolean>;
        ouiaType: PropTypes.Requireable<string>;
        polar: PropTypes.Requireable<boolean>;
        portalComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        portalZIndex: PropTypes.Requireable<number | undefined>;
        preserveAspectRatio: PropTypes.Requireable<string>;
        responsive: PropTypes.Requireable<boolean>;
        role: PropTypes.Requireable<string>;
        style: PropTypes.Requireable<object>;
        tabIndex: PropTypes.Requireable<number>;
        theme: PropTypes.Requireable<object>;
        title: PropTypes.Requireable<string>;
        width: PropTypes.Requireable<number | undefined>;
    };
    defaultProps: {
        allowDrag: boolean;
        allowDraw: boolean;
        allowResize: boolean;
        brushComponent: JSX.Element;
        brushStyle: {
            stroke: string;
            fill: string;
            fillOpacity: number;
        };
        handleComponent: JSX.Element;
        handleStyle: {
            stroke: string;
            fill: string;
        };
        handleWidth: number;
        mouseMoveThreshold: number;
        className: string;
        portalComponent: JSX.Element;
        portalZIndex: number;
        responsive: boolean;
        role: string;
    };
    defaultEvents: (props: any) => {
        target: string;
        eventHandlers: {
            onMouseDown: (evt: any, targetProps: any) => {};
            onTouchStart: (evt: any, targetProps: any) => {};
            onGlobalMouseMove: (evt: any, targetProps: any) => {} | undefined;
            onGlobalTouchMove: (evt: any, targetProps: any) => {} | undefined;
            onGlobalMouseUp: (evt: any, targetProps: any) => {};
            onGlobalTouchEnd: (evt: any, targetProps: any) => {};
            onGlobalTouchCancel: (evt: any, targetProps: any) => {};
        };
    }[];
} & TBase;
export declare const VictoryBrushContainer: {
    new (...args: any[]): {
        getSelectBox(props: any, coordinates: any): React.DetailedReactHTMLElement<{
            key: string;
            width: number;
            height: number;
            x: number;
            y: number;
            cursor: string;
            style: any;
        }, HTMLElement> | null;
        getCursorPointers(props: any): {
            yProps: string;
            xProps: string;
        };
        getHandles(props: any, domain: any): React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | null;
        getRect(props: any): (React.ReactElement<any, string | React.JSXElementConstructor<any>>[] | React.DetailedReactHTMLElement<{
            key: string;
            width: number;
            height: number;
            x: number;
            y: number;
            cursor: string;
            style: any;
        }, HTMLElement> | null)[];
        getChildren(props: any): (string | number | React.ReactElement<any, string | React.JSXElementConstructor<any>> | React.ReactFragment | null)[];
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<{}>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        render(): React.ReactNode;
        readonly props: Readonly<{}>;
        state: Readonly<{}>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidMount?(): void;
        shouldComponentUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): boolean;
        componentWillUnmount?(): void;
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<{}>, prevState: Readonly<{}>): any;
        componentDidUpdate?(prevProps: Readonly<{}>, prevState: Readonly<{}>, snapshot?: any): void;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<{}>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<{}>, nextState: Readonly<{}>, nextContext: any): void;
    };
    displayName: string;
    propTypes: {
        allowDrag: PropTypes.Requireable<boolean>;
        allowDraw: PropTypes.Requireable<boolean>;
        allowResize: PropTypes.Requireable<boolean>;
        brushComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        brushDimension: PropTypes.Requireable<string>;
        brushDomain: PropTypes.Requireable<PropTypes.InferProps<{
            x: PropTypes.Requireable<any[]>;
            y: PropTypes.Requireable<any[]>;
        }>>;
        brushStyle: PropTypes.Requireable<object>;
        defaultBrushArea: PropTypes.Requireable<string>;
        disable: PropTypes.Requireable<boolean>;
        handleComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        handleStyle: PropTypes.Requireable<object>;
        handleWidth: PropTypes.Requireable<number>;
        onBrushCleared: PropTypes.Requireable<(...args: any[]) => any>;
        onBrushDomainChange: PropTypes.Requireable<(...args: any[]) => any>;
        onBrushDomainChangeEnd: PropTypes.Requireable<(...args: any[]) => any>;
        "aria-describedby": PropTypes.Requireable<string>;
        "aria-labelledby": PropTypes.Requireable<string>;
        children: PropTypes.Requireable<string | number | boolean | PropTypes.ReactElementLike | PropTypes.ReactNodeArray>;
        className: PropTypes.Requireable<string>;
        containerId: PropTypes.Requireable<string | number>;
        containerRef: PropTypes.Requireable<(...args: any[]) => any>;
        desc: PropTypes.Requireable<string>;
        events: PropTypes.Requireable<object>;
        height: PropTypes.Requireable<number | undefined>;
        name: PropTypes.Requireable<string>;
        origin: PropTypes.Requireable<PropTypes.InferProps<{
            x: PropTypes.Requireable<number | undefined>;
            y: PropTypes.Requireable<number | undefined>;
        }>>;
        ouiaId: PropTypes.Requireable<string | number>;
        ouiaSafe: PropTypes.Requireable<boolean>;
        ouiaType: PropTypes.Requireable<string>;
        polar: PropTypes.Requireable<boolean>;
        portalComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        portalZIndex: PropTypes.Requireable<number | undefined>;
        preserveAspectRatio: PropTypes.Requireable<string>;
        responsive: PropTypes.Requireable<boolean>;
        role: PropTypes.Requireable<string>;
        style: PropTypes.Requireable<object>;
        tabIndex: PropTypes.Requireable<number>;
        theme: PropTypes.Requireable<object>;
        title: PropTypes.Requireable<string>;
        width: PropTypes.Requireable<number | undefined>;
    };
    defaultProps: {
        allowDrag: boolean;
        allowDraw: boolean;
        allowResize: boolean;
        brushComponent: JSX.Element;
        brushStyle: {
            stroke: string;
            fill: string;
            fillOpacity: number;
        };
        handleComponent: JSX.Element;
        handleStyle: {
            stroke: string;
            fill: string;
        };
        handleWidth: number;
        mouseMoveThreshold: number;
        className: string;
        portalComponent: JSX.Element;
        portalZIndex: number;
        responsive: boolean;
        role: string;
    };
    defaultEvents: (props: any) => {
        target: string;
        eventHandlers: {
            onMouseDown: (evt: any, targetProps: any) => {};
            onTouchStart: (evt: any, targetProps: any) => {};
            onGlobalMouseMove: (evt: any, targetProps: any) => {} | undefined;
            onGlobalTouchMove: (evt: any, targetProps: any) => {} | undefined;
            onGlobalMouseUp: (evt: any, targetProps: any) => {};
            onGlobalTouchEnd: (evt: any, targetProps: any) => {};
            onGlobalTouchCancel: (evt: any, targetProps: any) => {};
        };
    }[];
} & typeof VictoryContainer;
export declare type VictoryBrushContainer = typeof VictoryBrushContainer;
export {};
//# sourceMappingURL=victory-brush-container.d.ts.map