import PropTypes from "prop-types";
import React from "react";
import { Axis, DomainPropType, EventPropTypeInterface, OrientationTypes, VictoryAxisCommonProps, VictoryCommonProps, VictorySingleLabelableProps, EventsMixinClass } from "victory-core";
export declare type VictoryAxisTTargetType = "axis" | "axisLabel" | "grid" | "ticks" | "tickLabels" | "parent";
export interface VictoryAxisProps extends VictoryAxisCommonProps, VictoryCommonProps, VictorySingleLabelableProps {
    crossAxis?: boolean;
    domain?: DomainPropType;
    events?: EventPropTypeInterface<VictoryAxisTTargetType, number | string>[];
    fixLabelOverlap?: boolean;
    offsetX?: number;
    offsetY?: number;
    orientation?: OrientationTypes;
}
interface VictoryAxisBase extends EventsMixinClass<VictoryAxisProps> {
}
declare class VictoryAxisBase extends React.Component<VictoryAxisProps> {
    static animationWhitelist: Array<keyof VictoryAxisProps>;
    static displayName: string;
    static role: string;
    static defaultTransitions: {
        onExit: {
            duration: number;
        };
        onEnter: {
            duration: number;
        };
    };
    static propTypes: {
        axisComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        axisLabelComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        axisValue: PropTypes.Requireable<string | number | object>;
        categories: PropTypes.Requireable<(string | null | undefined)[] | PropTypes.InferProps<{
            x: PropTypes.Requireable<(string | null | undefined)[]>;
            y: PropTypes.Requireable<(string | null | undefined)[]>;
        }>>;
        crossAxis: PropTypes.Requireable<boolean>;
        dependentAxis: PropTypes.Requireable<boolean>;
        events: PropTypes.Requireable<(PropTypes.InferProps<{
            target: PropTypes.Requireable<string>;
            eventKey: PropTypes.Requireable<string | number | any[]>;
            eventHandlers: PropTypes.Requireable<object>;
        }> | null | undefined)[]>;
        fixLabelOverlap: PropTypes.Requireable<boolean>;
        gridComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        groupComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        invertAxis: PropTypes.Requireable<boolean>;
        label: PropTypes.Requireable<any>;
        offsetX: PropTypes.Requireable<number>;
        offsetY: PropTypes.Requireable<number>;
        orientation: PropTypes.Requireable<string>;
        origin: PropTypes.Requireable<PropTypes.InferProps<{
            x: PropTypes.Requireable<number>;
            y: PropTypes.Requireable<number>;
        }>>;
        stringMap: PropTypes.Requireable<object>;
        style: PropTypes.Requireable<PropTypes.InferProps<{
            parent: PropTypes.Requireable<object>;
            axis: PropTypes.Requireable<object>;
            axisLabel: PropTypes.Requireable<object>;
            grid: PropTypes.Requireable<object>;
            ticks: PropTypes.Requireable<object>;
            tickLabels: PropTypes.Requireable<object>;
        }>>;
        tickComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        tickCount: PropTypes.Requireable<number | null | undefined>;
        tickFormat: PropTypes.Requireable<((...args: any[]) => any) | unknown[]>;
        tickLabelComponent: PropTypes.Requireable<PropTypes.ReactElementLike>;
        tickValues: PropTypes.Requireable<unknown[] | undefined>;
        theme?: React.Validator<import("victory-core").VictoryThemeDefinition | null | undefined> | undefined;
        animate?: React.Validator<boolean | import("victory-core").AnimatePropTypeInterface | null | undefined> | undefined;
        colorScale?: React.Validator<import("victory-core").ColorScalePropType | null | undefined> | undefined;
        containerComponent?: React.Validator<React.ReactElement<any, string | React.JSXElementConstructor<any>> | null | undefined> | undefined;
        domainPadding?: React.Validator<import("victory-core").ForAxes<import("victory-core").PaddingType> | null | undefined> | undefined;
        externalEventMutations?: React.Validator<import("victory-core").EventCallbackInterface<string | string[], import("victory-core").StringOrNumberOrList>[] | null | undefined> | undefined;
        height?: React.Validator<number | null | undefined> | undefined;
        horizontal?: React.Validator<boolean | null | undefined> | undefined;
        maxDomain?: React.Validator<number | {
            x?: number | undefined;
            y?: number | undefined;
        } | null | undefined> | undefined;
        minDomain?: React.Validator<number | {
            x?: number | undefined;
            y?: number | undefined;
        } | null | undefined> | undefined;
        name?: React.Validator<string | null | undefined> | undefined;
        padding?: React.Validator<import("victory-core").PaddingProps | null | undefined> | undefined;
        polar?: React.Validator<boolean | null | undefined> | undefined;
        range?: React.Validator<import("victory-core").ForAxes<import("victory-core").RangeTuple> | null | undefined> | undefined;
        scale?: React.Validator<import("victory-core").D3Scale<any> | import("victory-core").ScaleName | {
            x?: import("victory-core").D3Scale<any> | import("victory-core").ScaleName | undefined;
            y?: import("victory-core").D3Scale<any> | import("victory-core").ScaleName | undefined;
        } | null | undefined> | undefined;
        sharedEvents?: React.Validator<{
            events: any[];
            getEventState: Function;
        } | null | undefined> | undefined;
        singleQuadrantDomainPadding?: React.Validator<boolean | {
            x?: boolean | undefined;
            y?: boolean | undefined;
        } | null | undefined> | undefined;
        standalone?: React.Validator<boolean | null | undefined> | undefined;
        width?: React.Validator<number | null | undefined> | undefined;
    };
    static defaultProps: {
        axisComponent: JSX.Element;
        axisLabelComponent: JSX.Element;
        tickLabelComponent: JSX.Element;
        tickComponent: JSX.Element;
        gridComponent: JSX.Element;
        standalone: boolean;
        theme: import("victory-core").VictoryThemeDefinition;
        containerComponent: JSX.Element;
        groupComponent: JSX.Element;
        fixLabelOverlap: boolean;
    };
    static getDomain: typeof Axis.getDomain;
    static getAxis: typeof Axis.getAxis;
    static getStyles: (props: any) => {
        parent: any;
        axis: any;
        axisLabel: any;
        grid: any;
        ticks: any;
        tickLabels: any;
    };
    static getBaseProps: (props: any) => {
        parent: {
            style: any;
            ticks: number[];
            standalone: any;
            theme: any;
            width: any;
            height: any;
            padding: any;
            domain: {
                x: any;
                y: any;
            };
        } & {
            scale: {
                [x: string]: import("victory-core").D3Scale<any> | undefined;
            };
            polar: any;
            horizontal: any;
            ticks: number[];
            stringTicks: any;
        };
    };
    static expectedComponents: Array<keyof VictoryAxisProps>;
    renderLine(props: any): React.FunctionComponentElement<{
        crossAxis: boolean;
        domain: import("victory-core").Tuple<number> | import("victory-core").Tuple<Date> | {
            x?: import("victory-core").DomainTuple | undefined;
            y?: import("victory-core").DomainTuple | undefined;
        };
        events: EventPropTypeInterface<VictoryAxisTTargetType, string | number>[];
        fixLabelOverlap: boolean;
        offsetX: number;
        offsetY: number;
        orientation: "left" | "bottom" | "right" | "top";
        axisComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        axisLabelComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        axisValue: string | number | object | Date;
        dependentAxis: boolean;
        disableInlineStyles: boolean;
        gridComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        invertAxis: boolean;
        style: {
            parent?: import("victory-core").VictoryStyleObject | undefined;
            axis?: import("victory-core").VictoryStyleObject | undefined;
            axisLabel?: import("victory-core").VictoryLabelStyleObject | import("victory-core").VictoryLabelStyleObject[] | undefined;
            grid?: import("victory-core").VictoryStyleObject | undefined;
            ticks?: import("victory-core").VictoryTickStyleObject | undefined;
            tickLabels?: import("victory-core").VictoryLabelStyleObject | import("victory-core").VictoryLabelStyleObject[] | undefined;
        };
        tickComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        tickCount: number;
        tickLabelComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        tickFormat: any[] | ((tick: any, index: number, ticks: any[]) => string | number);
        tickValues: any[];
        theme: import("victory-core").VictoryThemeDefinition;
        animate: boolean | import("victory-core").AnimatePropTypeInterface;
        colorScale: string[] | "grayscale" | "qualitative" | "heatmap" | "warm" | "cool" | "red" | "green" | "blue";
        containerComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        domainPadding: number | import("victory-core").Tuple<number> | {
            x?: import("victory-core").PaddingType | undefined;
            y?: import("victory-core").PaddingType | undefined;
        };
        externalEventMutations: import("victory-core").EventCallbackInterface<string | string[], import("victory-core").StringOrNumberOrList>[];
        groupComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        height: number;
        horizontal: boolean;
        maxDomain: number | {
            x?: number | undefined;
            y?: number | undefined;
        };
        minDomain: number | {
            x?: number | undefined;
            y?: number | undefined;
        };
        name: string;
        origin: import("victory-core").OriginType;
        padding: number | import("victory-core").BlockProps;
        polar: boolean;
        range: import("victory-core").RangeTuple | {
            x?: import("victory-core").RangeTuple | undefined;
            y?: import("victory-core").RangeTuple | undefined;
        };
        scale: import("victory-core").D3Scale<any> | "linear" | "time" | "log" | "sqrt" | {
            x?: import("victory-core").D3Scale<any> | import("victory-core").ScaleName | undefined;
            y?: import("victory-core").D3Scale<any> | import("victory-core").ScaleName | undefined;
        };
        sharedEvents: {
            events: any[];
            getEventState: Function;
        };
        singleQuadrantDomainPadding: boolean | {
            x?: boolean | undefined;
            y?: boolean | undefined;
        };
        standalone: boolean;
        width: number;
        label: string | ((data: any) => string | number | null);
        labelComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
    }>;
    renderLabel(props: any): React.FunctionComponentElement<{
        crossAxis: boolean;
        domain: import("victory-core").Tuple<number> | import("victory-core").Tuple<Date> | {
            x?: import("victory-core").DomainTuple | undefined;
            y?: import("victory-core").DomainTuple | undefined;
        };
        events: EventPropTypeInterface<VictoryAxisTTargetType, string | number>[];
        fixLabelOverlap: boolean;
        offsetX: number;
        offsetY: number;
        orientation: "left" | "bottom" | "right" | "top";
        axisComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        axisLabelComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        axisValue: string | number | object | Date;
        dependentAxis: boolean;
        disableInlineStyles: boolean;
        gridComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        invertAxis: boolean;
        style: {
            parent?: import("victory-core").VictoryStyleObject | undefined;
            axis?: import("victory-core").VictoryStyleObject | undefined;
            axisLabel?: import("victory-core").VictoryLabelStyleObject | import("victory-core").VictoryLabelStyleObject[] | undefined;
            grid?: import("victory-core").VictoryStyleObject | undefined;
            ticks?: import("victory-core").VictoryTickStyleObject | undefined;
            tickLabels?: import("victory-core").VictoryLabelStyleObject | import("victory-core").VictoryLabelStyleObject[] | undefined;
        };
        tickComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        tickCount: number;
        tickLabelComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        tickFormat: any[] | ((tick: any, index: number, ticks: any[]) => string | number);
        tickValues: any[];
        theme: import("victory-core").VictoryThemeDefinition;
        animate: boolean | import("victory-core").AnimatePropTypeInterface;
        colorScale: string[] | "grayscale" | "qualitative" | "heatmap" | "warm" | "cool" | "red" | "green" | "blue";
        containerComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        domainPadding: number | import("victory-core").Tuple<number> | {
            x?: import("victory-core").PaddingType | undefined;
            y?: import("victory-core").PaddingType | undefined;
        };
        externalEventMutations: import("victory-core").EventCallbackInterface<string | string[], import("victory-core").StringOrNumberOrList>[];
        groupComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        height: number;
        horizontal: boolean;
        maxDomain: number | {
            x?: number | undefined;
            y?: number | undefined;
        };
        minDomain: number | {
            x?: number | undefined;
            y?: number | undefined;
        };
        name: string;
        origin: import("victory-core").OriginType;
        padding: number | import("victory-core").BlockProps;
        polar: boolean;
        range: import("victory-core").RangeTuple | {
            x?: import("victory-core").RangeTuple | undefined;
            y?: import("victory-core").RangeTuple | undefined;
        };
        scale: import("victory-core").D3Scale<any> | "linear" | "time" | "log" | "sqrt" | {
            x?: import("victory-core").D3Scale<any> | import("victory-core").ScaleName | undefined;
            y?: import("victory-core").D3Scale<any> | import("victory-core").ScaleName | undefined;
        };
        sharedEvents: {
            events: any[];
            getEventState: Function;
        };
        singleQuadrantDomainPadding: boolean | {
            x?: boolean | undefined;
            y?: boolean | undefined;
        };
        standalone: boolean;
        width: number;
        label: string | ((data: any) => string | number | null);
        labelComponent: React.ReactElement<any, string | React.JSXElementConstructor<any>>;
    }> | null;
    renderGridAndTicks(props: any): React.FunctionComponentElement<{
        key: string;
    }>[];
    fixLabelOverlap(gridAndTicks: any, props: any): any;
    shouldAnimate(): boolean;
    render(): React.ReactElement;
}
export declare const VictoryAxis: {
    new (props: import("victory-core").EventMixinCommonProps): {
        state: {};
        getEventState: (eventKey: string | number, namespace: string, childType?: string | undefined) => any;
        getScopedEvents: (events: any, namespace: any, childType: any, baseProps: any) => {};
        getEvents: (p: any, target: any, eventKey: any) => any;
        externalMutations: {} | undefined;
        calculatedState: {};
        globalEvents: {};
        prevGlobalEventKeys: string[];
        boundGlobalEvents: {};
        shouldComponentUpdate(nextProps: import("victory-core").EventMixinCommonProps): boolean;
        componentDidMount(): void;
        componentDidUpdate(prevProps: any): void;
        componentWillUnmount(): void;
        addGlobalListener(key: any): void;
        removeGlobalListener(key: any): void;
        getStateChanges(props: any): {};
        applyExternalMutations(props: any, externalMutations: any): void;
        getCalculatedValues(props: any): import("victory-core").EventMixinCalculatedValues;
        getExternalMutations(props: import("victory-core").EventMixinCommonProps): {} | undefined;
        cacheValues(obj: any): void;
        getBaseProps(props: any, getSharedEventState: any): Record<string, object>;
        getAllEvents(props: any): any;
        getComponentProps(component: any, type: any, index: any): any;
        renderContainer(component: any, children: any): React.DetailedReactHTMLElement<any, HTMLElement>;
        animateComponent(props: import("victory-core").EventMixinCommonProps, defaultAnimationWhitelist: string[]): React.ReactElement<any, string | React.JSXElementConstructor<any>>;
        renderContinuousData(props: import("victory-core").EventMixinCommonProps): React.DetailedReactHTMLElement<any, HTMLElement>;
        renderData(props: any, shouldRenderDatum?: ((datum: any) => boolean) | undefined): React.DetailedReactHTMLElement<any, HTMLElement>;
        context: unknown;
        setState<K extends never>(state: {} | ((prevState: Readonly<{}>, props: Readonly<import("victory-core").EventMixinCommonProps>) => {} | Pick<{}, K> | null) | Pick<{}, K> | null, callback?: (() => void) | undefined): void;
        forceUpdate(callback?: (() => void) | undefined): void;
        render(): React.ReactNode;
        readonly props: Readonly<import("victory-core").EventMixinCommonProps>;
        refs: {
            [key: string]: React.ReactInstance;
        };
        componentDidCatch?(error: Error, errorInfo: React.ErrorInfo): void;
        getSnapshotBeforeUpdate?(prevProps: Readonly<import("victory-core").EventMixinCommonProps>, prevState: Readonly<{}>): any;
        componentWillMount?(): void;
        UNSAFE_componentWillMount?(): void;
        componentWillReceiveProps?(nextProps: Readonly<import("victory-core").EventMixinCommonProps>, nextContext: any): void;
        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<import("victory-core").EventMixinCommonProps>, nextContext: any): void;
        componentWillUpdate?(nextProps: Readonly<import("victory-core").EventMixinCommonProps>, nextState: Readonly<{}>, nextContext: any): void;
        UNSAFE_componentWillUpdate?(nextProps: Readonly<import("victory-core").EventMixinCommonProps>, nextState: Readonly<{}>, nextContext: any): void;
        componentEvents: import("victory-core/lib/victory-util/events").ComponentEvent[];
        getSharedEventState: (key: string, value: string) => unknown;
        baseProps: Record<string, object>;
        dataKeys: string[];
        hasEvents: unknown;
        events: unknown;
    };
    getBaseProps?(props: import("victory-core").EventMixinCommonProps): Record<string, object>;
    role?: string | undefined;
    expectedComponents?: string[] | undefined;
    getChildren?: ((props: import("victory-core").EventMixinCommonProps, childComponents?: React.ReactNode[] | undefined, calculatedProps?: import("victory-core").EventMixinCommonProps | undefined) => void) | undefined;
    animationWhitelist?: string[] | undefined;
} & typeof VictoryAxisBase;
export {};
//# sourceMappingURL=victory-axis.d.ts.map